# -*- coding: utf-8 -*-
"""app

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iepp9d7tNVXGEHWExOtxPVzzMCenqYfL
"""

!pip install python_speech_features
!pip install scipy
from __future__ import division, print_function
import os
import numpy as np
from flask import Flask, request ,render_template
from werkzeug.utils import secure_filename
from python_speech_features import mfcc
import scipy.io.wavfile as wav
import pickle
import operator

!pip install flask --quiet
!pip install flask-ngrok --quiet
print("Completed!")
!wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.tgz
!tar -xvf /content/ngrok-stable-linux-amd64.tgz
!./ngrok authtoken 2RsrSnmGIhHUJkBKX1VYjxKmIoC_BFAg3P2cmToSrVLbopo4
from flask_ngrok import run_with_ngrok

import random

app = Flask(__name__)
run_with_ngrok(app)
dataset = []

def loadDataset(filename, split, trset, teset):
    with open('mydataset.dat','rb') as f:
        while True:
            try:
                dataset.append(pickle.load(f))
            except EOFError:
                f.close()
                break
    for x in range(len(dataset)):
        if random.random() < split:
            trset.append(dataset[x])
        else:
            teset.append(dataset[x])

trainingSet = []
testSet = []
loadDataset('mydataset.dat', 0.68, trainingSet, testSet)

#distance function
def distance(instance1, instance2, k):
    distance = 0
    mm1 = instance1[0]
    cm1 = instance1[1]
    mm2 = instance2[0]
    cm2 = instance2[1]
    distance = np.trace(np.dot(np.linalg.inv(cm2), cm1))
    distance += (np.dot(np.dot((mm2-mm1).transpose(), np.linalg.inv(cm2)), mm2-mm1))
    distance += np.log(np.linalg.det(cm2)) - np.log(np.linalg.det(cm1))
    distance -= k
    return distance

# function to calculate the nearest neighbours

def getNeighbours(trainingset, instance, k):
  distances = []
  for x in range(len(trainingset)):
    dist = distance(trainingset[x],instance,k) + distance(instance,trainingset[x], k)
    distances.append((trainingset[x][2],dist))
  distances.sort(key=operator.itemgetter(1))
  neighbours = []
  for x in range(k):
    neighbours.append(distances[x][0])
  return neighbours

def nearestclass(neighbours):
  classvote = {}
  for x in range(len(neighbours)):
    response = neighbours[x]
    if response in classvote:
      classvote[response] += 1
    else:
      classvote[response] = 1
  sorter = sorted(classvote.items(),key = operator.itemgetter(1),reverse =True)
  return sorter[0][0]

@app.route('/',methods=['GET'])
def index():
  return render_template('index.html')

@app.route('/predict', methods=['GET','POST'])
def upload():
  if request.method == 'POST':
    f = request.files['audio_data']
    basepath = "UPLOADS"
    os.makedirs(basepath, exist_ok=True)
    file_path = os.path.join(basepath,secure_filename(f.filename))
    f.save(file_path)
    print(file_path)
    i=1
    results = {1: 'blues',2: 'classical',3:'country',4: 'disco',5: 'hiphop',6: 'jazz',7: 'metal',8: 'pop',9: 'reggae',10: 'rock'}
    (rate, sig) = wav.read(file_path)
    print(rate,sig)
    mfcc_feat = mfcc(sig, rate, winlen = 0.020, appendEnergy=False)
    covariance = np.cov(np.matrix.transpose(mfcc_feat))
    mean_matrix = mfcc_feat.mean(0)
    feature = (mean_matrix, covariance, 0)
    pred = nearestclass(getNeighbours(dataset,feature,5))
    print("Predicted genre = ",pred," class = ",results[pred])

    return render_template('index.html',prediction_text = "This song is classified as a" + str(results[pred]))

!pip install pyngrok
from pyngrok import ngrok
@app.route('/')
def home():
    ngrok_url = ngrok.connect(5000).public_url  # Retrieve ngrok URL
    return render_template('index.html', ngrok_url=ngrok_url)

from logging import debug

if __name__ == '__main__':
  app.run()